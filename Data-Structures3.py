import numpy as np
import pandas as pd
# ==================================================================================================================================
# Indexing / Selection
# --------------------------------------------------------------------------------------------------------
# Operation                              | Syntax                                  | Result
# --------------------------------------------------------------------------------------------------------
# 1. Select column                         df[col]                                   Series
# 2. Select row by label                   df.loc[label]                             Series
# 3. Select row by integer location        df.iloc[loc]                              Series
# 4. Slice rows                            df[5:10]                                  DataFrame
# 5. Select rows by boolean vector         df[bool_vec]                              DataFrame
# ==================================================================================================================================

# ▶▶▶ 다음과 같은 Row Selection은 Series를 반환한다
df = pd.DataFrame(
    data = {
        "COL1" : pd.Series([10, 20, 30, 40], index=['R1', 'R2', 'R3', 'R4']),
        "COL2" : [0x10, 0x20, 0x30, 0x40],
        "COL3" : np.linspace(-10, -5, 4),
        "COL4" : ("Country Pumpkin Pie", "Funky Lamb and Mushroom Sliders", "Classic New York Style Cheesecake", "Strawberry Thyme Tart"),
    }
)

print(df)
#     COL1  COL2       COL3                               COL4
# R1    10    16 -10.000000                Country Pumpkin Pie
# R2    20    32  -8.333333    Funky Lamb and Mushroom Sliders
# R3    30    48  -6.666667  Classic New York Style Cheesecake
# R4    40    64  -5.000000              Strawberry Thyme Tart
print(repr(df.loc['R1']))
print(type(df.loc['R1']))       # <class 'pandas.core.series.Series'>
print(type(df.loc[:,'COL1']))   # <class 'pandas.core.series.Series'>
print(type(df.loc[:,['COL1']])) # <class 'pandas.core.frame.DataFrame'>
print(type(df.iloc[3]))         # <class 'pandas.core.series.Series'>


# ==================================================================================================================================
# Data alignment and arithmetic
# ==================================================================================================================================
df = pd.DataFrame(np.random.randn(10, 4), columns=["A", "B", "C", "D"])
df2 = pd.DataFrame(np.random.randn(7, 3), columns=["A", "B", "C"])
print(df)
#           A         B         C         D
# 0 -0.439159  0.164132  0.049550  0.688170
# 1  0.763782 -0.266463  1.865563  0.037496
# 2  0.963469  0.263026 -0.971262  0.320913
# 3  0.986400 -0.039756  1.505295 -0.293668
# 4  1.212860  0.656544 -0.525058 -0.682296
# 5 -0.135400 -1.572603  0.445765  0.538936
# 6  0.282558 -0.648565 -0.531233 -0.197104
# 7 -0.788603  1.001872  0.496479 -0.398527
# 8  1.366751 -0.256894 -0.343732  0.130775
# 9  0.134790 -0.046151 -0.363125 -1.002256
print(df2)
#           A         B         C
# 0  0.662772 -1.027677  0.595030
# 1 -1.209031 -0.032574  0.557353
# 2  0.548020 -0.860691 -0.311432
# 3  0.787021 -0.963158  1.498449
# 4 -1.445916 -0.039338 -0.859551
# 5  1.892369 -0.061163 -0.546547
# 6  0.509884  1.628296 -1.002433

# ▶▶▶ DataFrame 객체 간의 데이터 정렬은 columns(열)와 index(행) 모두 자동으로 정렬된다.
# ▶▶▶ 다시 말하지만 결과 객체에는 열과 행 레이블(label)의 합집합이 있다
print(df + df2)
#           A         B         C   D
# 0  0.223613 -0.863545  0.644579 NaN
# 1 -0.445248 -0.299037  2.422916 NaN
# 2  1.511490 -0.597665 -1.282694 NaN
# 3  1.773421 -1.002913  3.003744 NaN
# 4 -0.233057  0.617206 -1.384610 NaN
# 5  1.756969 -1.633766 -0.100781 NaN
# 6  0.792443  0.979731 -1.533666 NaN
# 7       NaN       NaN       NaN NaN
# 8       NaN       NaN       NaN NaN
# 9       NaN       NaN       NaN NaN


# ▶▶▶ DataFrame과 Series간에 작업을 수행할 때 기본동작은 DataFrame 칼럼들에 Series 인덱스를 행 단위로(row-wise) 브로드캐스트 하는 것이다.
print(df - df.iloc[0]) # DataFrame타입 - Series타입
#           A         B         C         D
# 0  0.000000  0.000000  0.000000  0.000000
# 1  0.549040 -0.457485  1.066688 -0.517056
# 2  0.209060 -1.024916  2.116617 -1.125303
# 3 -0.703048 -0.255362  3.675230 -1.188849
# 4 -0.232660 -0.681182  2.281577 -2.922723
# 5 -0.786659 -1.290207  0.053077 -1.738580
# 6 -0.393005 -0.235489  2.703759 -0.689735
# 7  0.319494  0.750547  1.387225  0.092330
# 8  0.510812  0.197261  0.785895 -0.486891
# 9 -0.167807 -0.103944 -0.057381  0.855521


# ▶▶▶ 스칼라 연산은 뭐... 예상대로다
df = pd.DataFrame(
    np.arange(10, 33, 2).reshape(3, 4),
    index=['R1', 'R2', 'R3'],
    columns=['C1', 'C2', 'C3', 'C4']
)
print(df)
#     C1  C2  C3  C4
# R1  10  12  14  16
# R2  18  20  22  24
# R3  26  28  30  32

print(df * 5 + 2)
#      C1   C2   C3   C4
# R1   52   62   72   82
# R2   92  102  112  122
# R3  132  142  152  162

print(1 / df)
#           C1        C2        C3        C4
# R1  0.100000  0.083333  0.071429  0.062500
# R2  0.055556  0.050000  0.045455  0.041667
# R3  0.038462  0.035714  0.033333  0.031250

print(np.sqrt(df))
#           C1        C2        C3        C4
# R1  3.162278  3.464102  3.741657  4.000000
# R2  4.242641  4.472136  4.690416  4.898979
# R3  5.099020  5.291503  5.477226  5.656854

print(df ** 4)
#         C1      C2      C3       C4
# R1   10000   20736   38416    65536
# R2  104976  160000  234256   331776
# R3  456976  614656  810000  1048576

df1 = pd.DataFrame(
    {'A':[1, 0, 1], 'B':[0, 1, 1]}, dtype=bool
)
df2 = pd.DataFrame(
    {'A':[0, 1, 1], 'B':[1, 1, 0]}, dtype=bool
)

print(df1 & df2) # AND
#        A      B
# 0  False  False
# 1  False   True
# 2   True  False
print(df1 | df2) # OR
#       A     B
# 0  True  True
# 1  True  True
# 2  True  True
print(df1 ^ df2) # XOR
#        A      B
# 0   True   True
# 1   True  False
# 2  False   True
print(-df1)      # NOT
#        A      B
# 0  False   True
# 1   True  False
# 2  False  False

# ==================================================================================================================================
# Numpy 함수와 DataFrame의 상호 운용성
# 내부 데이터가 숫자라고 가정할 때, Numpy의 ufuncs(log, exp, sqrt, ...) 를 Series와 DataFrame에서 문제없이 사용할 수 있다.
# ==================================================================================================================================
df = pd.DataFrame(
    np.linspace(0, 40, 40).reshape(8, 5)
)
df.index=list(map(lambda x:'R'+str(x), [1,2,3,4,5,6,7,8]))
df.columns=tuple(map(lambda x:'C'+str(x), [1, 2, 3, 4, 5]))
print(df)
#            C1         C2         C3         C4         C5
# R1   0.000000   1.025641   2.051282   3.076923   4.102564
# R2   5.128205   6.153846   7.179487   8.205128   9.230769
# R3  10.256410  11.282051  12.307692  13.333333  14.358974
# R4  15.384615  16.410256  17.435897  18.461538  19.487179
# R5  20.512821  21.538462  22.564103  23.589744  24.615385
# R6  25.641026  26.666667  27.692308  28.717949  29.743590
# R7  30.769231  31.794872  32.820513  33.846154  34.871795
# R8  35.897436  36.923077  37.948718  38.974359  40.000000

print(np.asarray(df).__repr__())
# array([[ 0.        ,  1.02564103,  2.05128205,  3.07692308,  4.1025641 ],
#        [ 5.12820513,  6.15384615,  7.17948718,  8.20512821,  9.23076923],
#        [10.25641026, 11.28205128, 12.30769231, 13.33333333, 14.35897436],
#        [15.38461538, 16.41025641, 17.43589744, 18.46153846, 19.48717949],
#        [20.51282051, 21.53846154, 22.56410256, 23.58974359, 24.61538462],
#        [25.64102564, 26.66666667, 27.69230769, 28.71794872, 29.74358974],
#        [30.76923077, 31.79487179, 32.82051282, 33.84615385, 34.87179487],
#        [35.8974359 , 36.92307692, 37.94871795, 38.97435897, 40.        ]])

print(df.to_numpy().__repr__())
# array([[ 0.        ,  1.02564103,  2.05128205,  3.07692308,  4.1025641 ],
#        [ 5.12820513,  6.15384615,  7.17948718,  8.20512821,  9.23076923],
#        [10.25641026, 11.28205128, 12.30769231, 13.33333333, 14.35897436],
#        [15.38461538, 16.41025641, 17.43589744, 18.46153846, 19.48717949],
#        [20.51282051, 21.53846154, 22.56410256, 23.58974359, 24.61538462],
#        [25.64102564, 26.66666667, 27.69230769, 28.71794872, 29.74358974],
#        [30.76923077, 31.79487179, 32.82051282, 33.84615385, 34.87179487],
#        [35.8974359 , 36.92307692, 37.94871795, 38.97435897, 40.        ]])




